# class-bound-component

While CSS-in-JS approaches like styled-components have gained a lot of attention in the last couple of years you might be in a position where you can't or don't want to move to CSS-in-JS

- You might be using an external CSS library like Bootstrap
- You might be converting an old codebase to React and just want to focus on component functionality instead of also migrating all of your CSS to CSS-in-JS
- You might as well just not like CSS-in-JS

Still, you might want to have React components that abstract away the internals of your style sheets, or you're even using TypeScript and want to benefit from static types for styling components instead of raw class name strings.

This is where `class-bound-components` comes into play. It allows you to bind class names, be it global class name strings or even class names generated by `css-modules` to be bound to components. `classed-components` enables you to introduce an abstraction layer between style sheets and component usage that can also support a future migration from CSS-in-CSS to CSS-in-JS.

## Example

```tsx
import classBoundComponent from 'classed-components';
import './breadcrumb.css';

const Breadcrumb = classBoundComponent('breadcrumb', 'Breadcrumb', 'ol');
const BreadcrumbItem = classBoundComponent('breadcrumb-item', 'BreadcrumbItem', { isActive: 'active' }, 'li');
const BreadcrumbLink = classBoundComponent('breadcrumb-link', 'BreadcrumbLink', 'a');

const BreadcrumbContainer: React.FC<{ items: Item[]; activeId: number }> = ({ items, activeId }) => (
  <Breadcrumb aria-label="breadcrumb">
    {items.map(item => {
      <BreadcrumbItem key={item.id} isActive={item.id === activeId}>
        <BreadcrumbLink href={item.url} target="_blank">{item.name}</a>
      </BreadcrumbItem>
    })}
  </Breadcrumb>
);

const BreadcrumbButton = BreadcrumbLink.as('button');
const VisitableBreadcrumbLink = BreadcrumbLink.withVariants({ isVisited: 'visited' });
```

## API

### `classBoundComponent(options)`

Creates a new `ClassBoundComponent` from an options object with the following properties. Properties except `className` are optional.

<!-- prettier-ignore -->
|Name|Type|Description|
|-----|-----|-----|
|`className`|`ClassValue`<sup>1</sup>|Classes that are applied to the base component without any condition|
|`displayName`|`string`|Display name of the component created. This appears for instance in the React devtools. When omitted it's referred to as *Anonymous*|
|`variants`|`Record<string, ClassValue>`<sup>1</sup>|Object mapping the name of a variant, i.e., the name of the prop that has to be set to enable the variant, to a `ClassValue` that should be applied when the variant is enabled.|
|`elementType`|`React.ElementType<any>`|Type of element to use a the base for the component. May be any string recognized by `ReactDOM` or a custom React component. default: `'div'`|

<sup>1</sup> `ClassValue` refers to any kind of value that can be passed into the [`classnames` Function](https://github.com/JedWatson/classnames).

<!-- prettier-ignore -->
```tsx
const Button = classBoundComponent({
  className: 'custom-button',
  displayname: 'Button',
  variants: { isPrimary: 'primary', isCTA: ['secondary', 'cta'] },
  elementType: 'button'
});
```

### `classBoundComponent(className[, displayName[, variants[, elementType]]])`

Alias for `classBoundComponent(options)` containing all options defined above as positional arguments. Options except `className` can be omitted.

<!-- prettier-ignore -->
```tsx
const Button = classBoundComponent('custom-button', 'Button', { isPrimary: 'primary' }, 'button');
```

### `classBoundComponent(className[, variants[, elementType]])`

Alias for `classBoundComponent(options)` omitting the `displayName` option which will be set to `undefined` when calling this signature.

<!-- prettier-ignore -->
```tsx
const Button = classBoundComponent('custom-button', { isPrimary: 'primary' }, 'button');
Button.displayName === undefined;
```

### `ClassBoundComponent.as(elementType)`

Creates a copy of a `ClassBoundComponent` with similar options except the `elementType` being set to a different value

<!-- prettier-ignore -->
```tsx
const CustomButton = classBoundComponent('customButton', 'CustomButton', { isPrimary: 'primary' }, 'button');

// Oops need the same styles as an `<a />` tag
const CustomLink = CustomButton.as('a');

<CustomLink href="https://example.com/" target="_blank" isPrimary>Click me!</CustomLink>
         // ^ awesome! TypeScript allows these <a> specific props now!
```

### `ClassBoundComponent.withVariants(mergeVariants)`

Creates a copy of a `ClassBoundComponent` with similar options except the `variants` are merged with `mergeVariants`. While old variants that are not specified in the merge variants remain untouched, naming conflicts are resolved by preferring the variants in `mergeVariants`

<!-- prettier-ignore -->
```tsx
// button.tsx
import './buttons.css';

const BaseButton = classComponent('baseButton', 'BaseButton', { isPrimary: 'primary' }, 'button');

// my-custom-container.tsx
import 'my-custom-container.css';

const CustomButton = BaseButton.withVariants({
  isFlashy: 'flashyButton',
});

<CustomButton type="button" isPrimary isFlashy>Click me</CustomButton>
// renders <button type="button" className="baseButton primary flashyButton">Click me</button>
```

### `ClassBoundComponent.withOptions(mergeOptions)`

Creates a copy of a `ClassBoundComponent` with options that result from merging the original options with the `mergeOptions` shallowly. When merging, properties from `mergeOptions` have precedence over original properties.

### `ClassBoundComponent.withOptions(oldOptions => newOptions)`
